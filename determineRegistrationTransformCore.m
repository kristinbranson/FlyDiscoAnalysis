function registration = determineRegistrationTransformCore(varargin)

% parse inputs
[bkgdImage,...
 method,...
 circleImageType,...
 circleRLim,...
 circleXLim,...
 circleYLim,...
 circleImageThresh,...
 circleCannyThresh,...
 circleCannySigma,...
 circleNXTry,...
 circleNYTry,...
 circleNRTry,...
 nRotations,...
 minTemplateFeatureStrength,...
 maxDistCornerFrac_BowlLabel,...
 pairDist_mm,...
 circleRadius_mm,...
 bowlMarkerPairTheta_true,...
 markerPairAngle_true,...
 nBowlMarkers,...
 bowlMarkerType,...
 isInDebugMode,...
 imsavename,...
 hfig,...
 figpos,...
 useNormXCorr] = ...
  myparse(varargin,...
  'bkgdImage',[],...
  'method','normcorr',...
  'circleImageType','canny',...
  'circleRLim',[.475,.51],...
  'circleXLim',[.475,.525],...
  'circleYLim',[.475,.525],...
  'circleImageThresh',1,...
  'circleCannyThresh',[],...
  'circleCannySigma',[],...
  'circleNXTry',50,...
  'circleNYTry',50,...
  'circleNRTry',50,...
  'nRotations',20,...
  'minTemplateFeatureStrength',.92,...
  'maxDistCornerFrac_BowlLabel',.17,...
  'pairDist_mm',133,...
  'circleRadius_mm',63.5,...
  'bowlMarkerPairTheta_true',-3*pi/4,...
  'markerPairAngle_true',pi/6,...
  'nBowlMarkers',1,...
  'bowlMarkerType','gradient',...
  'debug',false,...
  'imsavename','',...
  'hfig',[],...
  'figpos',[10,10,1600,800],...
  'useNormXCorr',false);


% Error if no background image supplied
if isempty(bkgdImage) ,
  error('No background image supplied to detectRegistrationTransform()') ;
end

% Get basic dimensions
[nr,nc,~] = size(bkgdImage);
r = min(nr,nc);



%
% Determine where the chamber boundary is
%

% Only circle and flytracker methods are supported in FlyDisco
if ~(strcmpi(method, 'circle') || strcmpi(method, 'flytracker')) ,
  error('Unsupported method for chamber boundary detection: %s',method);  
end
% Depending on the circle image type, compute an image (circleim) that will be used for
% circle detection.
if strcmpi(circleImageType,'raw_whiteedge'),
  circleim = bkgdImage >= circleImageThresh;
elseif strcmpi(circleImageType,'raw_blackedge'),
  circleim = bkgdImage <= circleImageThresh;
elseif strcmpi(circleImageType,'grad'),
  gradI = [diff(bkgdImage,1,1).^2;zeros(1,nc)] + [diff(bkgdImage,1,2).^2,zeros(nr,1)];
  circleim = sqrt(gradI) >= circleImageThresh;
elseif strcmpi(circleImageType,'canny'),
  circleim = bkgdImage;
else
  error('Unknown circleImageType %s',circleImageType);
end
% Call the core circle-detection routine
binedgesx = linspace(circleXLim(1)*nc,circleXLim(2)*nc,circleNXTry+1);
bincentersy = linspace(circleYLim(1)*nr,circleYLim(2)*nr,circleNYTry);
bincentersr = linspace(circleRLim(1)*min(nc,nr),circleRLim(2)*min(nc,nr),circleNRTry);
[circleRadius,circleCenterX,circleCenterY,featureStrengths,circleDetectParams] = ...
  detectcircles(circleim,...
                'cannythresh',circleCannyThresh,'cannysigma',circleCannySigma,...
                'binedgesa',binedgesx,'bincentersb',bincentersy,'bincentersr',bincentersr,...
                'maxncircles',1,'doedgedetect',strcmpi(circleImageType,'canny'));



%
% Find the registration mark
%

% compute distance to corners
if nBowlMarkers>1 ,
  error('Only zero or one registration mark is currently supported') ;
end
if nBowlMarkers == 0 ,
  bowlMarkerPoints = zeros(2,0);
else
  if ~endsWith(bowlMarkerType, '.png') ,
    error('Only template-based registration mark types are currently supported.')
  end
  bowlMarkerTemplate = im2double(imread(bowlMarkerType));  % bowlMarkerType is the name of a .png image, perhaps surprisingly
  corner_radius = maxDistCornerFrac_BowlLabel * r ;
  bowlMarkerPoints = ...
    findTemplateMatchWithPossibleRotation(bkgdImage, bowlMarkerTemplate, minTemplateFeatureStrength, nRotations, useNormXCorr, corner_radius) ;
end



%
% Define the paramters of the transform used to register tracks.
%

% The origin is the center of the chamber circle.
originX = circleCenterX;
originY = circleCenterY;

% The offset is the vector you add to unregistered points to translate them
% s.t. points at the origin have registered coordinates of (0,0)/
offX = -originX;
offY = -originY;

% Determine the angle of the registration mark
if nBowlMarkers > 0 ,
  bowlMarkerPoint = mean(bowlMarkerPoints, 2, 'omitnan') ;
  bowlMarkerTheta = atan2(bowlMarkerPoint(2)-originY,bowlMarkerPoint(1)-originX);
else
  % Pretend the registration mark is in the upper-left corner of the image
  bowlMarkerTheta = atan2(1-originY,1-originX);  
end

% For FlyDisco, we assume that no rotation is needed to bring things into
% register.  In the FlyBowl era, there was often a n*90 degree rotation needed
% to bring things into register.
offTheta = 0;

% Compute the scale factor
scale = circleRadius_mm / circleRadius;  % mm/pixel



%
% Package everything up into the registration struct, save that to disk
% 
registerfn = @(x,y)(register(x,y,offX,offY,offTheta,scale)) ;
affine = affineTransform(offX,offY,offTheta,scale);
registration = ...
  struct('offX',offX,...
         'offY',offY,...
         'offTheta',offTheta,...
         'scale',scale,...
         'bowlMarkerTheta',bowlMarkerTheta,...
         'bkgdImage',bkgdImage,...
         'featureStrengths',featureStrengths,...
         'affine',affine, ...
         'bowlMarkerPoints', bowlMarkerPoints, ...
         'registerfn', registerfn, ...
         'circleCenterX', circleCenterX, ...
         'circleCenterY', circleCenterY, ...
         'circleRadius', circleRadius) ;
% Want registration to be a scalar struct, but circleDetectParams is a cell
% array.  So easier to tack it on here.
registration.circleDetectParams = circleDetectParams ;  

% create images illustrating fitting
saveRegistrationImage(imsavename, hfig, figpos, bkgdImage, circleCenterX, circleCenterY, circleRadius, ...
                      nBowlMarkers, bowlMarkerPoints, circleRadius_mm, originX, originY, offTheta, affine, ...
                      bowlMarkerPairTheta_true, scale) ;


% Make debug plot(s)
iscircle = true ;
makeRegistrationDebugPlots(isInDebugMode, iscircle, bkgdImage, circleRadius_mm, pairDist_mm, originX, originY, offTheta, ...
                           circleCenterX, circleCenterY, circleRadius, [], bowlMarkerPoints, ...
                           bowlMarkerPairTheta_true, markerPairAngle_true) ;
end  % function



function [x_reg,y_reg] = register(x,y,offX,offY,offTheta,scale)
% [x_reg,y_reg] = register(x,y,offX,offY,offTheta,scale)  
% Given unregistered coordinates <x,y>, add the offset <offX,offY>, rotate
% through angle offTheta, and scale by the *scalar* scale.  <x,y> are assumed to
% be in a Cartesian coordinate system, and the angle offTheta (as is usual)
% specifies a CCW rotation angle.  The resulting registered coordinates
% <x_reg,y_reg> are likewise in a Cartesian coordinate system.  (Yes, all of
% this is pretty much what you'd expect.
sz = size(x);
if numel(sz) ~= numel(size(y)) || ~all(sz == size(y)),
  error('Size of x and y must match');
end
costheta = cos(offTheta); sintheta = sin(offTheta);
X = [x(:)'+offX;y(:)'+offY];
X = [costheta,-sintheta;sintheta,costheta] * X * scale;
x_reg = reshape(X(1,:),sz);
y_reg = reshape(X(2,:),sz);
end  % function



function A = affineTransform(offX,offY,offTheta,scale)
costheta = cos(offTheta) ; 
sintheta = sin(offTheta) ;
Offset = [    1     0  0 ; ...
              0     1  0 ; 
           offX  offY  1 ] ;
Rotation = [  costheta  sintheta  0 ; ...
             -sintheta  costheta  0 ; ...
                     0         0  1 ] ;
Scale = [ scale      0  0 ; ...
              0  scale  0 ; ...
              0      0  1 ] ;
A = Offset * Rotation * Scale ;
% A = [1 0 0; 0 1 0; offX offY 1] * ...
%   [costheta sintheta 0; -sintheta costheta 0; 0 0 1] * ...
%   [scale 0 0; 0 scale 0; 0 0 1];
end  % function
