%% Regular (nonKine) data
ROOTPROJDIR = 'f:\stephenTrainingDataForMayanksTracker';
lblFile1 = fullfile(ROOTPROJDIR,'lbllist_nonKine_noneBodyAxis.txt');
lblFile2 = fullfile(ROOTPROJDIR,'lbllist_bodyAxis_level1.txt');
lbllist1 = importdata(lblFile1);
lbllist2 = importdata(lblFile2);
lbllist1 = fullfile(ROOTPROJDIR,lbllist1);
lbllist2 = fullfile(ROOTPROJDIR,lbllist2);
lbllist = [lbllist1;lbllist2];
nlbl = numel(lbllist);

fprintf('Read %d nonKineNonBodyaxis lbls. Read %d bodyAxis lbls. Total: %d\n',...
  numel(lbllist1),numel(lbllist2),nlbl);

tbl = lblCompileSH(lbllist);
%%
datestrMin = datestr(tbl.pLblTSmin,'yyyymmdd');
datestrMax = datestr(tbl.pLblTSmax,'yyyymmdd');
assert(isequal(datestrMin,datestrMax));
tbl = [tbl table(datestrMin,'VariableNames',{'pLblDate'})];
tbl(:,{'pLblTSmin' 'pLblTSmax'}) = [];
tbl.movFile = regexprep(tbl.movFile,'Z:/flp-chrimson_experiments','flp-chrimson_experiments');
% tbl.movFile = regexprep(tbl.movFile,'X:/flp-chrimson_experiments','flp-chrimson_experiments');
% tbl.movFile = regexprep(tbl.movFile,'\$datarootflp-chrimson_experiments','flp-chrimson_experiments');
% tbl.movFile = regexprep(tbl.movFile,'\$dataroot/flp-chrimson_experiments','flp-chrimson_experiments');
% tbl.movFile = regexprep(tbl.movFile,'W:/home/hustons/flp-chrimson_experiments','flp-chrimson_experiments');
tbl = sortrows(tbl,{'flyID' 'movID' 'frm'});

%% SH kine data: generated by running cells in loadStephensTrainingData labeled "RUN ME"
assert(isequal(tblKine.pLblTSmin,tblKine.pLblTSmax));
tblKine.pLblDate = datestr(tblKine.pLblTSmin,'yyyymmdd');
tblKine(:,{'pLblTSmin' 'pLblTSmax'}) = [];
tblKine = sortrows(tblKine,{'flyID' 'movID' 'frm'});

%%
nowstr = datestr(now,'yyyymmddTHHMMSS');
fname = sprintf('tblSHall_%s.mat',nowstr);
save(fname,'tbl','tblKine');

%%
load tblSHall_20180413T132301_hasdups.mat
t = [tbl;tblKine];

%% dup check
rowIDs = strcat(t.movID,'#',strtrim(cellstr(num2str(t.flyID))),'#',strtrim(cellstr(num2str(t.frm))));
[dupcats,idupcats] = finddups(rowIDs,'verbose',true);

%% deal with ID dups
% 1. Dups where all fields are identical except lbl-related, keep one of the
% rows. Prefer bAxis to HaB.
% 2. Dups where lbls are different, mark rows and discard
idxDupType1Rm = zeros(1,0); % we will just throw these rows away
idxDupType2Rm = zeros(1,0); % we will save these rows as a separate table
idxDupType2RmGrp = zeros(1,0); % group/label vector for rows of idxDupType2Rm
type2Ctr = 0;

for i=1:numel(dupcats)
  idx = dupcats{i};
  tDup = t(idx,:);
  
  tfMatch = true;
  MATCHFLDS = {'movFile' 'movID' 'movID2' 'flyID' 'frm' 'pLbl' 'pLblDate'};
  for j=2:height(tDup)    
    if ~isequal(tDup(1,MATCHFLDS),tDup(j,MATCHFLDS))
      tfMatch = false;
      break;
    end
  end
  
  if tfMatch
    %fprintf(1,'%d id-dup rows match in every way except lbl file.\n',height(tDup));
    tfHaB = strcmp('HaB',tDup.lblCat);
    tfBaxis = strcmp('bAxis',tDup.lblCat);
    if nnz(tfHaB)==1 && nnz(tfBaxis)==1
      idxDupType1Rm(1,end+1) = idx(tfHaB); % discard HaB; keep bAxis
    else
      assert(nnz(tfBaxis)==2);
      assert(numel(tDup.lblFile{1})<numel(tDup.lblFile{2})); % EMP: first lblFile has shorter/simpler name. Keep it
      idxDupType1Rm(1,end+1) = idx(2); % discard 2nd dup
    end
      
  else
    %fprintf(1,'!! %d id-dup rows: %s DO NOT match in every way except lbl file.\n',height(tDup),mat2str(idx));
    ndup = height(tDup);
    idxDupType2Rm = [idxDupType2Rm idx(:)'];
    type2Ctr = type2Ctr+1;
    idxDupType2RmGrp = [idxDupType2RmGrp repmat(type2Ctr,1,ndup)];
  end  
end

fprintf(1,'Will remove %d type 1 dup rows. Found %d type 2 dup grps/cats, for %d rows.\n',...
  numel(idxDupType1Rm),type2Ctr,numel(idxDupType2Rm));

tType2DupsLblsDiff = t(idxDupType2Rm,:);
tType2DupsLblsDiff = [table(idxDupType2RmGrp(:),'VariableNames',{'type2DupGrp'}) tType2DupsLblsDiff];
idxRmAll = [idxDupType1Rm(:); idxDupType2Rm(:)];
tIDdupsRmed = t;
tIDdupsRmed(idxRmAll,:) = [];
fprintf('%d rows removed.\n',numel(idxRmAll));
  
nowstr = datestr(now,'yyyymmddTHHMMSS');
fname = sprintf('tblSH_idDupsRemoved_%s.mat',nowstr);
save(fname,'tIDdupsRmed','tType2DupsLblsDiff');

%%
load tblSH_idDupsRemoved_20180415T095958.mat;
t = tIDdupsRmed;

%% repeat ID dup check
rowIDs = strcat(t.movID,'#',strtrim(cellstr(num2str(t.flyID))),'#',strtrim(cellstr(num2str(t.frm))));
[dupcats,idupcats] = finddups(rowIDs,'verbose',true); 
% EMP: no dup cats found

%% lbl dup check
[dupcatsLbl,idupcatsLbl] = finddups(t.pLbl,'verbose',true);
% [dupcatsLbl,idupcatsLbl] = finddups(tGood.pLbl,'verbose',true);

%% SH says pLbl dups are ok. browse them
for i=1:numel(dupcatsLbl)
  idx = dupcatsLbl{i};
  tdups = t(idx,{'lblCat' 'movID' 'frm'});    
  if isscalar(unique(tdups.movID)) && isequal(tdups.frm,(tdups.frm(1):tdups.frm(end))')
    fprintf('Standard\n');
  else
    fprintf('!!WEIRD!!\n');
  end
  disp(tdups)  
end

fprintf(1,'%d/%d rows are a dup label\n',nnz(~isnan(idupcatsLbl)),height(t));

% EMP: almost all dups are purely expected type (consec frames in a movie). 
% Two exception dupcats, are basically expected type but missing one frame 
% in sequence

%% 20180503 Browse dups in APT 
[~,iDCsort] = sort(cellfun(@numel,dupcatsLbl),'descend');

iDC = iDCsort(6);
rows = dupcatsLbl{iDC};
trow1 = t(rows(1),:);
movs = trow1.movFile_read;
movs = regexprep(movs,'/groups/branson/bransonlab','Y:\');
movs = regexprep(movs,'/groups/huston/hustonlab','Z:\');
if ~isequal(movs,lObj.movieFilesAll(lObj.currMovie,:))
  lObj.movieSetAdd(movs);
  lObj.movieSet(lObj.nmovies);
end
lObj.setFrame(trow1.frm-1);

nrows = numel(rows);
p = t(rows,:).pLbl;
p = reshape(p',10,2,nrows);
frms = t(rows,:).frm;
lObj.labeledpos{lObj.currMovie}(:) = nan;
lObj.labeledpos{lObj.currMovie}(:,:,frms) = p;

fprintf(1,'\n');
fprintf(1,'Dupcat %d, %d els.\n',iDC,nrows);
disp(movs);
fprintf(1,'Frames:\n');
disp(frms(:)');

% EMP: Browse the first ~6 cats. Usually the fly is not moving much. Taking
% the first frame out of ach dupcat seems fine. If anything the first frame
% seems typically the 'best'

%% 20180503 For each dupcat, remove all but first frame
tfRmDupCatLbl = false(height(t),1);
for i=1:numel(dupcatsLbl)
  rows = dupcatsLbl{i};
  assert(issorted(rows));
  assert(issorted(t(rows,:).frm));
  rowsRm = rows(2:end);
  tfRmDupCatLbl(rowsRm) = true;
  fprintf(1,'dupcat %d, removing %d rows\n',i,numel(rowsRm));
end

%% 20180503 Mislabel browse. Use Labeler/trainingMontage
% make some fake movs
movnames = {'vw1fake.avi' 'vw2fake.avi'};
NFRM = 5e3;
for i=1:2
  vw = VideoWriter(movnames{i});
  vw.open();
  for f=1:NFRM
    vw.writeVideo(zeros(1024,1024));
    if mod(f,100)==0
      disp(f);
    end
  end
  vw.close();
  fprintf(1,'Wrote vid %s\n',movnames{i});
end


%% 20180503 Mislabel browse. Use Labeler/trainingMontage
lObj.movieSetAdd(fullfile(pwd,movnames));
lObj.movieSet(lObj.nmovies);
iMov = lObj.currMovie;
nGood = height(tGood);
p = tGood.pLbl;
p = reshape(p',10,2,nGood);
lObj.labeledpos{iMov}(:) = nan;
lObj.labeledpos{iMov}(:,:,1:nGood) = p;
lObj.setFrame(1);

%% 20180503
xy = pLbl2xyvSH(tGood.pLbl);
xyc = mean(xy,2);
xyctrd = xy-xyc;

hFig = figure(11);
hFig.Position = [2561 401 1920 1124];
axs = createsubplots(1,2);
clrs = lines(5);
for ivw=1:2
  ax = axs(ivw);
  axes(ax);
  hold(ax,'on');
  axis(ax,'ij');
  h = gobjects(5,1);
  for ipt=1:5
    h(ipt) = plot(xyctrd(:,ipt,1,ivw),xyctrd(:,ipt,2,ivw),'.','markersize',8,'color',clrs(ipt,:));
  end
  if ivw==1
    legend(h,numarr2trimcellstr((1:5)'));
  end
end
    
%% 20180503 find L/R view2 switches
iLowerVw2Swap = find(xyctrd(:,2,1,2)>xyctrd(:,1,1,2));
iUpperVw2Swap = find(xyctrd(:,4,1,2)>xyctrd(:,3,1,2));
% EMP, these are the only real L/R Vw2 mislabel swaps
iUpperVw2Swap = [2027 3832];

%% 20180503 find L/R view2 switches
tfRm = tfRmDupCatLbl;
tfRm(iUpperVw2Swap) = true;

tMain20180503 = tFinalReconciled;
IMain20180503 = IFinalReconciled;
tMain20180503(tfRm,:) = [];
IMain20180503(tfRm,:) = [];

fprintf(1,'%d rows removed\n',nnz(tfRm));

save -v7.3 trnData20180503.mat tMain20180503 IMain20180503 tfRmDupCatLbl iUpperVw2Swap


  


%% SH data summary!
catC = categorical(t.lblCat);
catC = reordercats(catC,{'kine' '2016' '2017jan' '2017nov' 'bAxis'});
summary(catC)

%% rando
flyidC = categorical(t.flyID);
summary(flyidC)
idCatFlyC = catC.*flyidC;
idCatFlyC = removecats(idCatFlyC);
summary(idCatFlyC);

%% rando
flyIDun = unique(t.flyID);
for id=flyIDun(:)'
  tf = t.flyID==id;
  cats = unique(t.lblCat(tf));
  if ~isscalar(cats)
    fprintf(1,'id %d: %s\n',id,String.cellstr2CommaSepList(cats));
  end
end

%% Baxis/GT set vs nonGT
tfBaxis = catC=='bAxis';
nnz(tfBaxis)
tBaxis = t(tfBaxis,:);
tNotBaxis = t(~tfBaxis,:);
flyidBaxisUn = unique(tBaxis.flyID);

%% Baxis/GT set vs nonGT
tfFlyAppearsInNonBaxis = false(numel(flyidBaxisUn),1);
for i=1:numel(flyidBaxisUn)
  id = flyidBaxisUn(i);
  nBaxis = nnz(id==tBaxis.flyID);
  nnBaxis = nnz(id==tNotBaxis.flyID);
  tfFlyAppearsInNonBaxis(i) = nnBaxis>0;
  if nnBaxis>0
    fprintf(1,'FlyID %d appears in Baxis %d times and in nonBaxis %d times.\n',...
      id,nBaxis,nnBaxis);
  end
end
flyIDsAppearInNonBaxis = flyidBaxisUn(tfFlyAppearsInNonBaxis);
flyIDsBaxisOnly = flyidBaxisUn(~tfFlyAppearsInNonBaxis);
fprintf(1,'%d/%d Baxis flyIDs appear in nonBaxis lbls.\n',nnz(tfFlyAppearsInNonBaxis),numel(flyidBaxisUn));
fprintf(1,'%d/%d Baxis rows are with flies that dont appear in nonBaxis.\n',...
  nnz(ismember(tBaxis.flyID,flyIDsBaxisOnly)),height(tBaxis));

tfNonBaxisRowNotInBaxis = ~ismember(tNotBaxis.flyID,tBaxis.flyID);
fprintf(1,'%d/%d nonBaxis rows are with flies that dont appear in Baxis.\n',...
  nnz(tfNonBaxisRowNotInBaxis),height(tNotBaxis));
