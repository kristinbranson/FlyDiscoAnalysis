function rotDeg = rotAroundAxis_SJH(Q,axisWantRotAround)
% takes quaternion describing rotation and tries to find the magnitude of
% that rotation around the requested axis (axisWantRotAround) - Google swing
% twist quaternion decomposition for more info.
%
% axisWantRotAround = [x,y,z]; axis you want to project the rotation onto
% to find the magnitude of rotation around this axis.
%
% Q = quaternion describing real rotation that occured in [w x y z] format generated by qGetQ.m
%
% rotDeg = rotation component around axisWantRotAround in degrees
%
% NO IDEA HOW THIS WORKS!!!!!! JUST COPIED MATH FROM
% getAngleAroundRad() in libgdx/gdx/src/com/badlogic/gdx/math/Quaternion.java https://github.com/libgdx/libgdx/blob/166ad3887a90aa6ee49f99b007f992da8fe5e87c/gdx/src/com/badlogic/gdx/math/Quaternion.java
% HAVE TESTED ON REAL DATA VERSUS NUMERICAL SEARCH AND IT PRODUCES SOLUTION
% VERY CLOSE TO NUMERICAL SEARCH OUTPUT SO CONFIDENT IT WORKS.  SEE
% projec3Drot2singleAxis.m for test code - switch between method 1 and 2 to
% test this gives sensible output for your data.

%checking quaternion contains something
if all(Q==zeros(4,1))
    error('Quaternion is all zeros, please make sure it contains data')
end

%normalizing
Q = qNormalize(Q);
axisWantRotAround = axisWantRotAround/norm(axisWantRotAround);

%normalizing just xyz component of quaternion for use in dot product
Qxyz = Q(2:4);
QxyzNorm = Qxyz/norm(Qxyz);

%dot product between quaternion xyz component and axis want rotation angle around
%d = dot(Q(2:4), axisWantRotAround); 
d = dot(QxyzNorm, axisWantRotAround); 

newQ = [Q(1), Q(2)*d, Q(3)*d, Q(4)*d];

%'length' but without square root 'len2()' in libgdx
l2 = sum( newQ .* newQ );

if l2==0
    
  rotRad = 0;
  
elseif d<0

    x = (-1*Q(1)) / sqrt(l2);
    if x>1
        x=1;
        warning('X>1')
    elseif x<-1
        x=-1;
        warning('X<-1')
    end
    rotRad = 2 * acos(x);

elseif d>=0

    x = Q(1) / sqrt(l2);
    if x>1
        x=1;
        warning('X>1')
    elseif x<-1
        x=-1;
        warning('X<-1')
    end
    rotRad = 2 * acos(x);

else
  error('something went horribly wrong.')
end

%wrappiong to -pi to pi
i = rotRad<-pi;
rotRad(i)=rotRad+(2*pi);
i = rotRad>pi;
rotRad(i)=rotRad-(2*pi);

if isnan(rotRad)
    error('rotRad == NaN!')
end

%converting to degrees
rotDeg = sjh_rad2deg(rotRad);
