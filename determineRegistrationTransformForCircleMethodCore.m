function registration_data = determineRegistrationTransformForCircleMethodCore(varargin)
% The core routine for fitting the chamber border, computing the registration
% transform, and finding the registration mark, when using the 'circle'
% registration method.
%
% This is a pure function, unless debug is true.  Then it makes some plots but
% it otherwise pure.

% parse inputs
[bkgdImage,...
 circleImageType,...
 circleRLim,...
 circleXLim,...
 circleYLim,...
 circleImageThresh,...
 circleCannyThresh,...
 circleCannySigma,...
 circleNXTry,...
 circleNYTry,...
 circleNRTry,...
 nRotations,...
 minTemplateFeatureStrength,...
 maxDistCornerFrac_BowlLabel,...
 pairDist_mm,...
 circleRadius_mm,...
 bowlMarkerPairTheta_true,...
 markerPairAngle_true,...
 nBowlMarkers,...
 bowlMarkerTemplate,...
 isInDebugMode,...
 useNormXCorr] = ...
  myparse(varargin,...
  'bkgdImage',[],...
  'circleImageType','canny',...
  'circleRLim',[.475,.51],...
  'circleXLim',[.475,.525],...
  'circleYLim',[.475,.525],...
  'circleImageThresh',1,...
  'circleCannyThresh',[],...
  'circleCannySigma',[],...
  'circleNXTry',50,...
  'circleNYTry',50,...
  'circleNRTry',50,...
  'nRotations',20,...
  'minTemplateFeatureStrength',.92,...
  'maxDistCornerFrac_BowlLabel',.17,...
  'pairDist_mm',133,...
  'circleRadius_mm',63.5,...
  'bowlMarkerPairTheta_true',-3*pi/4,...
  'markerPairAngle_true',pi/6,...
  'nBowlMarkers',1,...
  'bowlMarkerTemplate',[],...
  'debug',false,...
  'useNormXCorr',false);


% Error if no background image supplied
if isempty(bkgdImage) ,
  error('No background image supplied to %s()', mfilename()) ;
end
if isempty(bowlMarkerTemplate) ,
  error('No registration mark template supplied to %s()', mfilename()) ;
end

% Get basic dimensions
[nr,nc,~] = size(bkgdImage);
r = min(nr,nc);



%
% Determine where the chamber boundary is
%

% Depending on the circle image type, compute an image (circleim) that will be used for
% circle detection.
if strcmpi(circleImageType,'raw_whiteedge'),
  circleim = bkgdImage >= circleImageThresh;
elseif strcmpi(circleImageType,'raw_blackedge'),
  circleim = bkgdImage <= circleImageThresh;
elseif strcmpi(circleImageType,'grad'),
  gradI = [diff(bkgdImage,1,1).^2;zeros(1,nc)] + [diff(bkgdImage,1,2).^2,zeros(nr,1)];
  circleim = sqrt(gradI) >= circleImageThresh;
elseif strcmpi(circleImageType,'canny'),
  circleim = bkgdImage;
else
  error('Unknown circleImageType %s',circleImageType);
end

% Call the core circle-detection routine
binedgesx = linspace(circleXLim(1)*nc,circleXLim(2)*nc,circleNXTry+1);
bincentersy = linspace(circleYLim(1)*nr,circleYLim(2)*nr,circleNYTry);
bincentersr = linspace(circleRLim(1)*min(nc,nr),circleRLim(2)*min(nc,nr),circleNRTry);
[circleRadius,circleCenterX,circleCenterY,featureStrengths,circleDetectParams] = ...
  detectcircles(circleim,...
                'cannythresh',circleCannyThresh,'cannysigma',circleCannySigma,...
                'binedgesa',binedgesx,'bincentersb',bincentersy,'bincentersr',bincentersr,...
                'maxncircles',1,'doedgedetect',strcmpi(circleImageType,'canny'));



%
% Find the registration mark
%

% compute distance to corners
if nBowlMarkers>1 ,
  error('Only zero or one registration mark is currently supported') ;
end
if nBowlMarkers == 0 ,
  bowlMarkerPoints = zeros(2,0);
else
  corner_radius = maxDistCornerFrac_BowlLabel * r ;
  bowlMarkerPoints = ...
    findTemplateMatchWithPossibleRotation(bkgdImage, bowlMarkerTemplate, minTemplateFeatureStrength, nRotations, useNormXCorr, corner_radius) ;
end



%
% Define the paramters of the transform used to register tracks.
%

% The origin is the center of the chamber circle.
originX = circleCenterX;
originY = circleCenterY;

% The offset is the vector you add to unregistered points to translate them
% s.t. points at the origin have registered coordinates of (0,0)/
offX = -originX;
offY = -originY;

% Determine the angle of the registration mark
if nBowlMarkers > 0 ,
  bowlMarkerPoint = mean(bowlMarkerPoints, 2, 'omitnan') ;
  bowlMarkerTheta = atan2(bowlMarkerPoint(2)-originY,bowlMarkerPoint(1)-originX);
else
  % Pretend the registration mark is in the upper-left corner of the image
  bowlMarkerTheta = atan2(1-originY,1-originX);  
end

% For FlyDisco, we assume that no rotation is needed to bring things into
% register.  In the FlyBowl era, there was often a n*90 degree rotation needed
% to bring things into register.
offTheta = 0;

% Compute the scale factor
scale = circleRadius_mm / circleRadius;  % mm/pixel



%
% Package everything up into the registration struct, save that to disk
% 
registerfn = @(x,y)(registerForSingleAffine(x,y,offX,offY,offTheta,scale)) ;
affine = affineTransformMatrixFromOffsetsAndScale(offX,offY,offTheta,scale);
registration_data = ...
  struct('offX',offX,...
         'offY',offY,...
         'offTheta',offTheta,...
         'scale',scale,...
         'bowlMarkerTheta',bowlMarkerTheta,...
         'bkgdImage',bkgdImage,...
         'featureStrengths',featureStrengths,...
         'affine',affine, ...
         'bowlMarkerPoints', bowlMarkerPoints, ...
         'registerfn', registerfn, ...
         'circleCenterX', circleCenterX, ...
         'circleCenterY', circleCenterY, ...
         'circleRadius', circleRadius) ;
% Want registration to be a scalar struct, but circleDetectParams is a cell
% array.  So easier to tack it on here.
registration_data.circleDetectParams = circleDetectParams ;  

% Make debug plot(s)
iscircle = true ;
makeRegistrationDebugPlots(isInDebugMode, iscircle, bkgdImage, circleRadius_mm, pairDist_mm, originX, originY, offTheta, ...
                           circleCenterX, circleCenterY, circleRadius, [], bowlMarkerPoints, ...
                           bowlMarkerPairTheta_true, markerPairAngle_true) ;





